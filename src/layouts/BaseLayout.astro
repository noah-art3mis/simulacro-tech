---
import Navigation from '../components/Navigation.astro';
import Footer from '../components/Footer.astro';
import '../styles/global.css';

interface Props {
	title?: string;
}

const { title = 'Simulacro Tech - Interdisciplinary Data & AI Consultancy' } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Data and AI consultancy grounded in ethics. Building technology that serves people, not the other way around." />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/png" href={`${import.meta.env.BASE_URL.replace(/\/$/, '')}/simulacro.png`} />
		<title>{title}</title>
	</head>
	<body class="overflow-x-hidden">
		<!-- Animated network canvas -->
		<canvas id="network-canvas" class="fixed inset-0 pointer-events-none z-0"></canvas>
		
		<!-- Noise texture overlay -->
		<div class="noise-overlay"></div>
		
		<div class="min-h-screen flex flex-col relative z-10">
			<Navigation />
			<main class="flex-grow relative">
				<slot />
			</main>
			<Footer />
		</div>

		<script>
			// Network particle animation
			const canvas = document.getElementById('network-canvas') as HTMLCanvasElement;
			const ctx = canvas.getContext('2d');
			let particles: Particle[] = [];
			const PARTICLE_COUNT = 60;
			const CONNECTION_DISTANCE = 150;
			let animationId: number;
			let mouseX = -1000;
			let mouseY = -1000;

			function resize() {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
			}

			class Particle {
				x: number;
				y: number;
				vx: number;
				vy: number;
				radius: number;
				baseRadius: number;

				constructor() {
					this.x = Math.random() * canvas.width;
					this.y = Math.random() * canvas.height;
					this.vx = (Math.random() - 0.5) * 0.4;
					this.vy = (Math.random() - 0.5) * 0.4;
					this.baseRadius = Math.random() * 1.5 + 0.5;
					this.radius = this.baseRadius;
				}

				update() {
					this.x += this.vx;
					this.y += this.vy;

					// Bounce off edges
					if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
					if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

					// Mouse interaction - particles grow near cursor
					const dx = this.x - mouseX;
					const dy = this.y - mouseY;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < 150) {
						this.radius = this.baseRadius + (1 - dist / 150) * 2;
					} else {
						this.radius = this.baseRadius;
					}
				}

				draw() {
					if (!ctx) return;
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
					ctx.fillStyle = 'rgba(245, 158, 11, 0.5)';
					ctx.fill();
				}
			}

			function drawConnections() {
				if (!ctx) return;
				for (let i = 0; i < particles.length; i++) {
					for (let j = i + 1; j < particles.length; j++) {
						const dx = particles[i].x - particles[j].x;
						const dy = particles[i].y - particles[j].y;
						const dist = Math.sqrt(dx * dx + dy * dy);

						if (dist < CONNECTION_DISTANCE) {
							const opacity = 0.12 * (1 - dist / CONNECTION_DISTANCE);
							ctx.beginPath();
							ctx.moveTo(particles[i].x, particles[i].y);
							ctx.lineTo(particles[j].x, particles[j].y);
							ctx.strokeStyle = `rgba(245, 158, 11, ${opacity})`;
							ctx.lineWidth = 0.5;
							ctx.stroke();
						}
					}
				}

				// Draw connections to mouse
				particles.forEach(p => {
					const dx = p.x - mouseX;
					const dy = p.y - mouseY;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < 200) {
						const opacity = 0.2 * (1 - dist / 200);
						ctx.beginPath();
						ctx.moveTo(p.x, p.y);
						ctx.lineTo(mouseX, mouseY);
						ctx.strokeStyle = `rgba(139, 92, 246, ${opacity})`;
						ctx.lineWidth = 0.8;
						ctx.stroke();
					}
				});
			}

			function animate() {
				if (!ctx) return;
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				particles.forEach(p => {
					p.update();
					p.draw();
				});
				
				drawConnections();
				animationId = requestAnimationFrame(animate);
			}

			function init() {
				resize();
				particles = [];
				for (let i = 0; i < PARTICLE_COUNT; i++) {
					particles.push(new Particle());
				}
				animate();
			}

			window.addEventListener('resize', () => {
				resize();
			});

			window.addEventListener('mousemove', (e) => {
				mouseX = e.clientX;
				mouseY = e.clientY;
			});

			window.addEventListener('mouseleave', () => {
				mouseX = -1000;
				mouseY = -1000;
			});

			init();
		</script>

		<script>
			// Scroll reveal animation
			const revealObserver = new IntersectionObserver((entries) => {
				entries.forEach(entry => {
					if (entry.isIntersecting) {
						entry.target.classList.add('revealed');
					}
				});
			}, { 
				threshold: 0.1,
				rootMargin: '0px 0px -50px 0px'
			});

			// Observe all sections for reveal
			document.querySelectorAll('section').forEach(el => {
				el.classList.add('reveal-on-scroll');
				revealObserver.observe(el);
			});

			// Also observe elements with reveal-on-scroll class
			document.querySelectorAll('.reveal-on-scroll').forEach(el => {
				revealObserver.observe(el);
			});
		</script>
	</body>
</html>
